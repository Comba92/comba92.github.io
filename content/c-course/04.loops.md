+++
date = '2025-06-24T11:26:09+02:00'
draft = false
linkTitle = ''
title = 'ClangCourseLoops'
summary = ''
author = 'Comba92'
tags = []
keywords = []
+++

TODO: due parole sul copy pasting
## While loop
Abbiamo visto come effettuare decisioni usando gli If/Else.
A volte vogliamo anche effettuare le stesse operazioni più volte. Copiare e incollare codice sembra a volta la scelta più semplice... ma non dovresti mai neanche azzardarti. Vedremo come copiare codice è la fonte di tutti i mali della programmazione.
Se vogliamo ripetere un numero di istruzioni più volte, usiamo i cicli **while**.

Il ciclo while funziona in modo simile all'if. Ecco la sua sintassi:
```c
while (espressione) {
  statement1;
  statement2;
  ...
}
```
Se l'espressione è vera, entriamo nel blocco. Raggiunta la fine del blocco, l'espressione viene rivalutata. Se è ancora vera, il blocco ricomncia daccapo. Questo ciclo continua fino a che l'espressione non valuta a falso. A quel punto, l'esecuzione continua subito dopo il blocco while.

Con i loop come il while nasce il problema di possibili loop infiniti. Se la condizione duante l'esecuzione del blocco, il programma non terminerebbe mai. A quel punto sarai costretto a terminarlo forzatamente, usando `Ctrl`+`C` dal terminale. Non c'è alcun modo di prevedere e gestire un loop infinito per il computer: esiste un famoso enunciato, il [problema della terminazione, o halting problem](https://it.wikipedia.org/wiki/Problema_della_terminazione), che lo dimostra.

Come l'if, le graffe possono essere omesse se vi è una sola istruzione nel blocco.
Inoltre, tutte le bullshit mostrate nella lezione precedente presenti nell'if riguardano anche il while.

## Break e continue
I loop offrono due keyword speciali per gestire la loro esecuzione.
Se si raggiunge uno statement *break*, l'esecuzione del loop terminerà all'istante, uscendo dal blocco, indipendemente dalla condizione tra parentesi.
Se si raggiunge uno statement *continue* invece, il loop ricomincia subito daccapo come se fosse arrivato alla fine del blocco.

Se più while sono innestati, i break e continue si riferiranno sempre al loop più in profondità (un po' come funziona per gli else e i loro relativi if); per esempio:
```c
  while (a) {
    ...
    while (b) {
      ...
      while (c) {
        if (d) break;
        ... 
      }
    }
  }
```
Il break uscirà solamente dal while più interno (con la condizione c). L'esecuzione riprenderà dunque da riga 9.

## Do-while
Una versione diversa del while esiste, il **do-while**. Questo è di solito usato molto più raramente. Però vediamolo per completezza.
La sua sintassi è questa:
```c
do {
  statment1;
  statement2;
  ...
} while (espressione)
```
Il funzionamento è lo stesso. L'unica differenza è che l'espressione viene valutata alla FINE del ciclo, non all'inizio. In pratica, questo significa che eseguiremo sempre almeno il primo ciclo, e la condizione verrà controllata per quelli successivi.
Il do-while può tornare utile in rari casi, ma preferisco sempre usare il semplice while.

## Una nota sul goto
TODO

## Intermezzo
Finalmente, direi che abbiamo accumulato abbastanza conoscenza per poter scrivere i nostri primi programmi. 

## FizzBuzz
```c
#include <stdio.h>

void main() {
  int i = 0;
  while (i <= 100) {
    printf("%d ", i);
    if (i % 3 == 0) printf("Fizz");
    if (i % 5 == 0) printf("Buzz");
    printf("\n");
  }
}
```

## Triangolo ASCII
```c
#include <stdio.h>

void main() {
  int row = 0;
  int len = 0;

  while (row < 20) {
    while (len < row) {
      printf("#");
      len += 1;
    }
    len = 0;
    row += 1;
    printf("\n");
  }
}
```

## Scacchiera ASCII
```c
#include <stdio.h>

void main() {
  int row = 0;
  int len = 0;

  while (row < 20) {
    while (len < 20) {
      int row_is_even = row % 2 == 0;
      if (len % 2 == row_is_even) printf("#");
      else printf(" ");
      len += 1;
    }

    len = 0;
    row += 1;
    printf("\n");
  }
}
```


## Il primo progetto: Indovina il numero
```c
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

void main() {
  bool should_restart = true;

  while(should_restart) {
    srand(time(0));
    int number_to_guess = rand() % 100;
    printf("Indovina il numero!\n");

    int guesses = 10;
    int user_input;

    while(guesses > 0) {
      printf("> ");
      scanf("%d", &user_input);

      if (user_input > number_to_guess) {
        printf("Il tuo numero e' troppo alto. Riprova!\n");
      } else if (user_input < number_to_guess) {
        printf("Il tuo numero e' troppo basso. Riprova!\n");
      } else {
        printf("Hai indovinato!\n");
        break;
      }

      guesses -= 1;
    }

    if (guesses == 0) {
      printf("Hai finito i tentativi.\n");
    }
    printf("Se vuoi continuare a giocare, scrivi qualsiasi numero diverso da 0.\n");
    printf("> ");
    scanf("%d", &user_input);
    should_restart = user_input != 0;
  }
}
```