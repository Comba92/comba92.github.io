+++
date = '2025-06-23T23:45:10+02:00'
draft = false
linkTitle = ''
title = 'ClangCourseConditions'
summary = ''
author = 'Comba92'
tags = []
keywords = []
+++
https://en.wikipedia.org/wiki/Statement_(computer_science)
https://en.wikipedia.org/wiki/Expression_(computer_science)
https://en.wikipedia.org/wiki/Conditional_(computer_programming)

https://eloquentjavascript.net/02_program_structure.html

## Operatori Relazionali
Introduciamo altri operatori del C: quelli di [uguaglianza](https://it.wikipedia.org/wiki/Uguaglianza_(matematica)) e [diseguaglianza](https://it.wikipedia.org/wiki/Disuguaglianza).
Il termine relazionale deriva dal loro nome matematico (si chiamano [relazioni binarie](https://it.wikipedia.org/wiki/Relazione_(matematica))).
Questi sono:
- uguaglianza `==`
- non uguaglianza `!=`
- maggiore `>`, maggiore uguale `>=`
- minore `<`, minore uguale `<=`

Il risultato di questi operatori è sempre o un si, oppure un no.
Possiamo dire che i loro risultati vengono valutati come un valore booleano, ovvero un valore che può essere solo 'vero' o 'falso'.
Linguaggi di programmazione moderni introducono un nuovo *tipo* per le variabili, il [booleano](https://it.wikipedia.org/wiki/Booleano_(informatica)), per rappresentare questi risultati.
C non dispone di un tipo booleano!! Quindi, per rappresentare vero o falso, usa sempre il tipo numerico. Il valore 'false' è rappresentato con il numero 0, mentre 'true' con il numero 1. Qualsiasi altro numero rappresenta comunque il valore 'true'.

Da ora in avanti, quando ci riferiremo a espressioni vere, a volte le chiamerò *nonzero*, mentre per quelle false, a volte le chiamerò semplicemente *zero*.
(occhio che `=` (assegnamento) e `==` (uguaglianza) sono due operatori diversi!)

```c
10 == 10; // risulta 1, 10 è uguale a 10
10 != 10; // risulta 0, 10 non è diverso da 10
int valore = 69;
int relazione = valore != 420 // risulta1, 69 è diverso da 420
```

Gli operatori relazionali inoltre hanno una precedenza piu bassa degli operatori aritmetici, quindi vengono sempre valutati per ultimi.
```c
scrivere
5 + 43 >= 23 - 3
è come scrivere
(5 + 43) >= (23 - 3) // risulta 1, 48 è maggiore di 20
```

C-bullshit: la libreria standard dispone di un header chiamato stdbool.h, che definisce le keyword/sinonimi per 'true' e 'false'. Includerla permette di usare le due keyword come valori booleani.

## Operatori Logici
Introduciamo altri 3 operatori, gli [operatori logici (o booleani)](https://it.wikipedia.org/wiki/Algebra_di_Boole#Operatori_booleani):
- NOT logico (complemento) `!`
- AND logico (unione) `&&`
- OR logico (intersezione) `||`
Questi operatori si aspettano due operandi booleani, e il loro risultato è ancora un booleano.
(attenzione che `&` e `&&` sono operatori diversi, stesso vale per `|` e `||`. `&` e `|` sono operatori 'bitwise', che operano sui bit).
Assumo molti di voi sappiano già come funzionano, ma probabilmente sei una schiappa in matematica, quindi ripassiamoli velocemente.

NOT è unario, e inverte un booleano. !0 = 1, e !1 = 0.
AND risulta 1 solo se entrambi gli operandi sono 1. 1 && 1 = 1, 0 && 1 = 0, 0 && 0 = 0
OR risulta 1 solo se almeno uno degli operandi è 1. 1 || 1 = 1, 0 || 1 = 1, 0 || 0 = 0.

La precedenza di questi operatori va ricordata. Il NOT ha precedenza più alta.
AND e OR hanno precedenza più bassa degli operatori relazionali, e AND ha più precedenza di OR. Io nel dubbio metto sempre delle parentesi, per esplicitare la precedenza.
Ora, ricordare le regole di precedenza non è facile (probabilmente non le ricordo neanche io). Se non si è certi della precedenza, consiglio di esplicitare sempre l'ordine con le parentesi. Salverà un bel po' di mal di testa in futuro.

// TODO: explain short circuit
Una proprietà peculiare degli operatori logici è lo [short circuit](https://en.wikipedia.org/wiki/Short-circuit_evaluation).

Ci sono altri operatori che non abbiamo esplorato, quelli ['bitwise'](https://it.wikipedia.org/wiki/Operazione_bit_a_bit). Questi operano sui singoli bit. Il loro simbolo è simile a quelli logici:
- NOT bitwise `~`
- AND bitwise `&`
- OR bitwise `|`
- XOR `^`
- Shift a sinistra `<<`
- Shift a destra `>>`
Questi operatori hanno utilizzi più rari e tecnici, e al momento non ci interessano. Avremo occasione di vederli in una lezione futura, ma per ora ho voluto solo accennarli.

C-bullshit: come nel caso dei bool, c'è un header chiamato [ciso646.h](https://cplusplus.com/reference/ciso646/) che definisce le keyword/sinonimi per gli operatori logici. Prima di scrivere questa lezione, non ero al corrente della sua esistenza, e ho visto raramente persone usare queste keyword al posto dei simboli per gli operatori.

// TODO: remove this
## Espressioni e statements
Un'*espressione* è un'istruzione che viene valutata ad un determinato valore.
Il termine 'valutare' è la mia italianizzazione del termine 'to evaluate'.
I calcoli con gli operatori che abbiamo visto fin'ora sono tutte espressioni, dato che valutano un nuovo valore.
```c
1 + 1 // espressione, valutata a 2
int risultato = 5 + 1; // la parte a destra dell'uguale è un'espressione valutata a 6
```
L'accesso ad una variabile risulta in un'espressione, dato che viene valutata al valore contenuto dalla variabile.
Un literal è di per sé un'espressione.
Come vedremo dopo, anche le chiamate a funzione sono espressioni. Se hai implementato il teorema di Pitagora nella scorsa lezione, avrai notato come la funzione sqrt() ritorni un valore.

Gli *statements*, sono istruzioni che non risultano in alcun valore valutato. Esprimono delle istruzioni o comandi che vengono eseguiti nel linguaggio.
Gli statement in C sono di solito terminati dal punto e virgola `;`.
Dichiarare una variabile o una funzione è uno statement; non viene valutato alcun valore.
L'assegnamento è uno statement, dato che esegue un'azione che non viene valutata ad alcun valore. Gli assegnamenti possono però avere espressioni nella parte destra (o sinistra).
Anche i blocchi sono statement, dato che sono solo contenitori di una lista di istruzioni, come lo sono gli if/else, while e for che vedremo a breve.

Linguaggi di programmazione moderni potrebbero aspettarsi un valore di ritorno da un blocco, e quindi rendere il blocco non più uno statement ma un espressione.
In sunto, le espressioni vengono valutate, gli statement vengono eseguiti. Inoltre, gli statement possono essere composti da espressioni, mentre non vale il contrario.

C-bullshit: in realtà ho mentito: in C, l'assegnamento è un'espressione, che viene valutata al valore assegnato. Questo non succede di norma nei linguaggi moderni. Non è buona pratica pensare all'assegnamento come espressione, quindi continuerò a trattarlo come uno statement.

Un espressione di assegnamento permette di fare cose di questo tipo:
```c
int numero1;
int numero2 = numero1 = 10;
int numero2 = (numero1 = 10);
```
Dato che l'espressione `numero1 = 10` viene valutata al valore assegnato, ovvero 10, possiamo usare l'espressione come parte destra dell'assegnamento a numero2.

Possiamo anche fare cose orribili tipo questa:
```c
int valore = 5;
if (valore = 10) {}
```
Cosa sta succedendo qui? Un assegnamento dentro una condizione di if. In questo caso l'assegnamento viene valutato come 10, ed essendo non-zero, la condizione sarà vera, ed entreremo nel blocco dell'if.
Programmatori principianti potrebbero confondere l'assegnamento con l'eguaglianza (valore == 10 risulterebbe in 0 invece, quindi non entreremmo nell'if), e quindi non notare del grosso sbaglio commesso.

## Blocchi e scopes
Un **blocco** è una parte di codice racchiusa tra parentesi graffe `{` e `}`. L'unico blocco che abbiamo visto fino ad ora è quello della funzione main.
```c
int main() {
  // tutto il nostro codice racchiuso qui...
}
```
E' possibile creare altri blocchi annidati. Ogni blocco deve essere terminato, e non può essere più lungo del blocco che lo contiene.
Per ora, limitiamoci a creare altri blocchi solo all'interno del main.
```c
int main() {
  {
    // un blocco vuoto
  }

  {
    // un altro blocco vuoto
    {
      // un blocco vuoto annidato
    }
  }

  { // ERRORE! questo blocco non è stato chiuso
}
```
Per chiarità e leggibilità del codice, è buona norma indentare con un tab i contenuti di un blocco. Al compilatore gli spazi e le indentazioni non interessano, e le ignora completamente.
Questo codice è totalmente valido e uguale a quello sopra, ma orribile da leggere:
```c
// questo è lo stesso codice dell'esempio sopra!!
int main() {{}{{}}}
```
I blocchi vuoti non hanno molto senso. I blocchi sono utili perché provvedono un meccanismo di [scoping](https://en.wikipedia.org/wiki/Scope_(computer_science)). Se dichiariamo delle variabili dentro un blocco, queste saranno accessibili solamente da dentro il blocco, e non da fuori. Inoltre, le variabili dichiarate dentro un blocco verranno eliminate alla fine del blocco.
Gli esempi valgono più di mille parole:
```c
int main() {
  int var_main;

  {
    int var1 = 50;
    var_main = 20;
  } // var1 muore qui

  {
    // var1 non esiste più, quindi posso riusare il suo nome in questo blocco.
    int var1;
    var1 = 10;

    {
      int var2 = 2;
      var1 = 5; // posso accedere a var1, dato che sono ancora dentro blocco in cui è definita
    } // var2 muore qui

    var = 1;
  } // var1 muore qui

  var2 = 10; // ERRORE: non esiste più alcuna variabile chiamata var2

  // var_main muore qui
}
```
Le variabili che abbiamo creato fino ad ora si chiamano locali, appunto perché sono locali al loro scope/blocco. Non possiamo accederle al di fuori dello blocco in cui sono dichiarate.
Questo è un concetto estremamente importante che è di solito sorvolato.
Notiamo anche che il blocco preso per intero è considerato un singolo statement (statement composto), contenente altri statement al suo interno.

### Caso particolare: shadowing delle variabili
I blocchi permettono anche il riutilizzo dei nomi. Quando una variabile muore il suo nome può essere riutilizzato senza creare conflitti. Un caso particolare di questo riutilizzo è lo [shadowing](https://en.wikipedia.org/wiki/Variable_shadowing). Lo shadowing permette di dichiarare una variabile internamente ad un blocco, anche se il blocco più esterno ne presenta già una con lo stesso nome. La variabile esterna verrà ignorata temporaneamente all'interno del blocco, e sarà riaccessibile alla fine del blocco.
```c
int i = 1; // variabile esterna
{
  int i = 2; // variabile interna con lo stesso nome, applicato shadowing
  // la i esterna diventa temporaneamente inacessibile

  printf("%d\n", i); // questo stamperà 2
} // i interna muore qui

// i esterna è ora riacessibile
printf("%d\n", i); // questo stamperà 1
```
Lo shadowing è semplicemente una comodità per il programmatore, dal punto di vista tecnico o semantico, non è nulla di particolare. 

## If/Else
Fino ad ora abbiamo scritto programmi sequenziali e lineari, senza alcun tipo di decisione. Introduciamo ora il concetto di controllo condizionale.
In base alla veridicità di una condizione, possiamo scegliere se eseguire un blocco oppure no, esprimendo una decisione.
Possiamo farlo con un **If** statement. La sua sintassi è questa:
```c
if (espressione) {
  statement1;
  statement2;
  ...
}
```
Se l'espressione tra parentesi tonde è vera, l'esecuzione entrerà nel blocco dopo l'if, altrimenti l'esecuzione continuerà subito dopo la fine del blocco.
```c
int risultato = 10;
if (risultato > 5) {
  printf("Il risultato supera 5!");
}
```
La condizione dell'if valuterà a vera, e verrà eseguito il blocco con il printf.
Spesso vorremmo eseguire qualcosa nel caso contrario. Possiamo aggiungere un blocco else, opzionale:
```c
if (espressione) {
  ...
} else {
  statement1;
  statement2;
  ...
}
```
Funziona come prima, solo che se l'espressione dell'if è falsa, verrà eseguito solamente il blocco else. Se la condizione è vera, verrà eseguito solamente il blocco if.
Ogni else è associato al proprio relativo if.

Attenzione. Se il blocco if/else contiene una sola istruzione, le graffe possono essere omesse:
```c
if (espressione) statement1;
else statement2;
```
Se per errore dimentichi le graffe e hai un blocco con piu' istruzioni, il compilatore non ti può aiutare. Questo è un caso di errore di semantica.
```c
if (espressione) 
  statment1;
  statement2;
```
In questo caso, statement2 verrà eseguito in ogni caso, perché solo statement1 è parte del blocco dell'if. Abbiamo pure aggiunto un bel tab che ci fa illudere gli statement appartengano allo stesso blocco. Ahia!!
Ricorda che i tab al compilatore non interessano!
Lo stesso discorso vale per i blocchi else.
Dato che il blocco else è opzionale, bisogna stare attenti alle ambiguità quando li omettiamo.
Considera questo esempio:
```c
if (expr1)
  if (expr2) stmt1
  else stmt2
```
In questo caso l'else è collegato al secondo if (come mostra l'indentazione) non al primo. Se vuoi che sia collegato al primo if, sei costretto ad usare le parentesi:
```c
if (expr1) {
  if (expr2) stmt1
} else stmt2
```

A volte può salvare un po di typing omettere le graffe, ma consiglio di inserirle nel 99% dei casi, anche per evitare ambiguità e casi strani.

Piu' if/else possono essere concatenati:
```c
if (a) {
  ...
} else if (b) {
  ...
} else if (c) {
  ...
} else {
  ...
}
```
In questo esempio, le condizioni vengono evaluate in ordine.
Se il primo if fallisce, verrà provato il secondo. Se anche il secondo fallise, verrà provato il terzo. Se tutti falliscono, si finisce all'else finale. Se solo uno ha successo, tutti gli altri blocchi vengono ignorati. Se per esempio, la condizione `a` è falsa e la condizione `b` è vera, solo il blocco della condizione b verrà eseguito, a prescindere dal fatto che c sia vero o meno.

Nulla ci vieta di annidare if e else come ci pare e comporre sequenze più complesse:
```c
if (a) {
  printf("a");

  if (b) {
    printf("b è vero");
  } else if (c) {
    printf("b è vero");
  } else if (d) {
    printf("d è vero");
  } else {
    printf("b, c, d sono falsi\n");
  }

  if (e) {
    printf("e è vero");
  }
} else {
  printf("a è falso\n");

  if (f) {
    printf("fè vero");
  }
  if (g) {
    printf("g è vero");
  } else {
    printf("g è falso\n")
    if (h) {
      printf("h è vero");
    }
  }
}
```
Un esempio un po' intricato, ma utile per farvi capire il funzionamento dell'if/else. Ogni else è collegato al proprio if. Copialo come di consueto nel tuo programma, e gioca con le condizioni per vedere cosa viene stampato. Concatenare if e else in questo modo crea una specie di gerarchia ad albero, alla quale dovrai presto abituarti a visualizzare mentalmente.

C-bullshit:
Attenzione a non fare cacate del genere:
```c
if (espressione); {
  ...
}
```
Dato che le graffe possono essere omesse dai blocchi if, il `;` dopo l'espressione tra parentesi vale come statement vuoto! Il blocco dopo l'if verrà SEMPRE eseguito.
Questo è quello che succede, riscrivendolo in maniera un pò piu esplicita.
```c
if (espressione) {
  ;
}
...
```

Ancora peggio:
```c
if (condizione = 0) {
  ...
}
```
Una cosa del genere è destinata a capitare ad ogni programmatore con il 101% di probabilità. Invece di controllare l'eguaglianza con 0, abbiamo scritto un `=` in meno. Ora abbiamo un assegnamento, che non solo sovrascrive la variabile 'condizione' con 0, ma anche farà sempre fallire il blocco if. Ecco perché, imo, gli assegnamenti dovrebbero essere trattati come statement; situazioni del genere possono essere problematiche. Non usare mai assegnamenti in condizioni (a meno che tu non sia un matto o un programmatore degli anni 90).

## Operatore ternario
TODO