+++
date = '2025-06-24T08:04:31+02:00'
draft = false
linkTitle = ''
title = 'ClangCourseTypes'
summary = ''
author = 'Comba92'
tags = []
keywords = []
+++
https://en.wikipedia.org/wiki/Scope_(computer_science)
https://en.wikipedia.org/wiki/Name_resolution_(programming_languages)
https://en.wikipedia.org/wiki/Variable_shadowing
https://en.wikipedia.org/wiki/Local_variable
https://en.wikipedia.org/wiki/Global_variable

https://en.wikipedia.org/wiki/Data_type
https://en.wikipedia.org/wiki/Primitive_data_type
https://en.wikipedia.org/wiki/Type_conversion

Basta cazzate; ci siamo levati di torno i concetti basilari dei linguaggi di programmazione. Il vero corso inizia ora. Iniziamo ad introdurre nuovi tipi.

## Tipi primitivi
Fino ad ora, abbiamo solamente lavorato con valori di tipo int. Per l'uso comune, gli int sono sufficienti. Esistono però altri tipi di valori numerici. I valori numerici sono alla base di tutti gli altri tipi; vengono chiamati infatti *tipi primitivi*. Sono la forma di dato più piccola e semplice che il computer può gestire.
I tipi primitivi si distinguono dai tipi composti, che esamineremo nel dettaglio più avanti. Abbiamo già incontrato un tipo composto, le stringhe.

## Numeri e rappresentazione
Per poter essere rappresentato da un computer, un numero deve salvato in formato binario. In base alla dimensione del numero, ci sarà la necessita di un certo numero di cifre binarie per rappresentarlo. Per esempio, il numero 1337, in binario è 1001100110111: abbiamo 12 cifre binarie. Questo significa che per rappresentare 1337 ci servono ALMENO 12 bit di memoria.
Per funzionare in maniera efficiente, le architetture di CPU scelgono una dimensione di bit massima per i numeri sul quale possono effettuare i calcoli. Di solito le dimensioni sono potenze di due, come 8bit, 16bit, 32bit, o 64bit. Quando parliamo di un 'sistema a 32bit', ci stiamo appunto riferendo alla dimensione dei registri della CPU, e con la dimensione massima di numeri binari col quale possono lavorare. Architetture diverse supporteranno dimensioni di numeri diverse.

Il linguaggio C nasce come un linguaggio compilabile in qualsiasi architettura; offre quindi la flessibilità di scegliere diverse dimensioni per le variabile numeriche.
Il tipo int che abbiamo usato fino ad ora non definisce un valore numerico di dimensione precisata; ma definisce il valore numerico "nativo" della relativa architettura in cui compiliamo.
Questo significa che la dimensioni delle variabili int differisce in base all'architettura di compilazione.

Per esempio, nelle architetture MIPS il tipo int "nativo" è l'intero a 32bit. Questo è il tipo più efficiente e veloce per l'architettura. Lavorare con numeri 8bit o 16bit in questo caso richiederà un piccolo overhead di conversione a 32bit.
Nel 2025, la stragrande maggioranza dei computer usano l'architettura x86_64; questa supporta registri di 8bit, 16bit, 32bit, e 64bit. In pratica, nessuno dei 4 presenta alcun overhead. In questa architettura il tipo int si riferisce a interi 32bit.

C offre anche il tipo char, short, long, long long, e così via. Purtroppo anche questi dipendendono dall'architettura.
In x86_64 char è 8bit, short 16bit, long 32 bit (grazie C), long long 64 bit.

## Signed vs Unsigned
Un'altra distinzione va fatta per il tipo signed e unsigned:
I tipi signed ammettono un segno, mentre gli unsigned no.
I tipi primitivi sono signed di default.
Per la variante di tipo unsigned va usata la keyword **unsigned** prima del tipo.
```c
unsigned int a = 10;
```
I tipi unsigned portano pochi vantaggi rispetto ai signed. I tipi signed necessitano di 1 bit per salvare il segno, dimezzando quindi il range di valori rappresentabili. Gli unsigned usano il bit di segno per usare l'intero range di valori. Questo trade off è spesso contro producente dato che spesso vogliamo effettuare sottrazioni con il segno!
Gli unsigned andrebbero usati solamente quando sei ASSOLUTAMENTE SICURO di averne bisogno.

Per evitare l'ambiguità dell'architettura, C offre anche tipi di dimensione fissa (non dipendenti dall'architettura).
Questi tipi sono definiti nell'header stdint.h (per esempio, l'intero a 32bit è definito come uint32 per unsigned e int32 per signed).
Linguaggi più moderni scelgono addirittura di chiamare i tipi con u32 per gli unsigned o s32/i32 per i signed, che penso sia molto più comodo e facile da ricordare.

| Tipo | std | Dimensione | Range | printf Formatter |
| ---- | -------- | ---------- | ----- | ---------------- |
| `char` | `int8_t` | 8 bit - 1 byte | -127, 127 | `%c` oppure `%d` |
| `unsigned char` | `uint8_t` | 8 bit - 1 byte | 0, 255 | `%c` oppure `%u` |
| `short` | `int16_t` | 16 bit - 2 byte | -2^15, 2^15-1 | `%d` |
| `unsigned short` | `unt16_t` | 16 bit - 2 byte | 0, 2^16 | `%u` |
| `int` | `int32_t` | 32 bit - 4 byte | -2^31, 2^31-1 | `%d` |
| `unsigned int` | `uint32_t` | 32 bit - 4 byte | 0, 2^32 | `%u` |
| `long` | `int64_t` | 64 bit - 8 byte | -2^63, 2^63-1 | `%ld` |
| `unsigned long` | `uint64_t` | 64 bit - 8 byte | 0, 2^64 | `%lu` |
| `float` |  | 32 bit - 4 byte |  | `%f` |
| `double` |  | 64 bit - 8 byte |  | `%f` |

## Overflow e introduzione all' Undefined Behavior (UB)
## Conversioni esplicite: Casting
## Conversioni implicite: Promozione
## Costanti
